#lang racket
; attempt of solving the 8queen problem.
(define (map f l)
  (cond ((eq? l '()) '())
        (else (cons (f (car l)) (map f (cdr l))))))
(define (foldr op terminator seq)
  (cond ((eq? seq '()) terminator)
        (else (op (car seq) (foldr op terminator (cdr seq))))))
(define (neatMap f l)
  (foldr append '() (map f l)))
(define (remove x s)
  (filter (lambda (z) (not (eq? x z))) s))
(define (permutation s)
  (if (eq? s '()) (list '()) (neatMap (lambda (x) (map (lambda (p) (cons x p)) (permutation (remove x s)))) s)))
(define (iota x)
  (define (iotaInt x count res)
    (if (eq? count (+ x 1)) res (iotaInt x (+ count 1) (append res `(,count)))))
  (iotaInt x 1 '()))
(define (index x)
  (define (indexInt x index)
    (cond ((eq? x '()) '())
          (else (cons (list index (car x)) (indexInt (cdr x) (+ index 1))))))
  (indexInt x 1))
(define (pairFrom x)
  (neatMap (lambda (z) (map (lambda (y) (list z y)) (remove z x))) x))
(define (notSafe x y)
  (define (takeAsVector x y) (list (- (car y) (car x)) (- (cadr y) (cadr x))))
  (let ((vecX (car (takeAsVector x y)))
        (vecY (cadr (takeAsVector x y))))
    (or (eq? vecX 0)
        (eq? vecY 0)
        (eq? (abs vecX) (abs vecY)))))
(define (fullAnd x)
  (cond ((eq? x '()) #t) ((not (car x)) #f) (else (fullAnd (cdr x)))))
(define (allRes)
  (define (safe? x)
    (fullAnd (map (lambda (z) (not (notSafe (car z) (cadr z)))) (pairFrom (index x)))))
  (filter safe? (permutation (iota 8))))
