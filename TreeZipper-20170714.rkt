; '(a b (c d (e f)) d (e f) f) '()
; Goto 2 ==>
; '(c d (e f)), (((0 . a) (1 . b) 2 (3 . (e f)) (4 . d) (5 . (e f)) (6 . f)))
; Goto 2 ==>
; (e f), (((0 . c) (1 . d) 2)
;         ((0 . a) (1 . b) 2 (3 . (e f)) (4 . d) (5 . (e f)) (6 . f)))
; Goto 0 ==>
; e, ((0 (1 . f))
;     ((0 . c) (1 . d) 2)
;     ((0 . a) (1 . b) 2 (3 . (e f)) (4 . d) (5 . (e f)) (6 . f)))
; Set '(g h) ==>
; '(g h), ((0 (1 . f))
;          ((0 . c) (1 . d) 2)
;          ((0 . a) (1 . b) 2 (3 . (e f)) (4 . d) (5 . (e f)) (6 . f)))
; Back ==>
; '((g h) f), (((0 . c) (1 . d) 2)
;              ((0 . a) (1 . b) 2 (3 . (e f)) (4 . d) (5 . (e f)) (6 . f)))
; Back ==>
; '(c d ((g h) f)), (((0 . a) (1 . b) 2 (3 . (e f)) (4 . d) (5 . (e f)) (6 . f)))
; Back ==>
; '(a b (c d ((g h) f)) (e f) d (e f) f), '()
(define (tagOf x) (car x))
(define (makeHole r tree)
  (for/list ((i tree) (j (in-range 0 (length tree))))
    (if (= j r) j (cons j i))))
(define (recover tree trail)
  (for/list ((i trail))
    (if (pair? i) (cdr i) tree)))
(define (rebuild tree trailList)
  (if (null? trailList) tree (rebuild (recover tree (car trailList)) (cdr trailList))))
(define (extend tree)
  (if (null? tree) '(()) (cons (car tree) (extend (cdr tree)))))
(define (delete n tree)
  (if (= n 0) (cdr tree) (cons (car tree) (delete (- n 1) (cdr tree)))))
(define (mkTreeZipper)
  (define tree '())
  (define trail '())
  (define (dispatch x)
    (cond ((equal? (tagOf x) 'Goto)
           (begin (set! trail (cons (makeHole (cadr x) tree) trail))
                  (set! tree (list-ref tree (cadr x)))))
          ((equal? (tagOf x) 'Set)
           (set! tree (cadr x)))
          ((equal? (tagOf x) 'Back)
           (begin (set! tree (recover tree (car trail)))
                  (set! trail (cdr trail))))
          ((equal? (tagOf x) 'GetTree) tree)
          ((equal? (tagOf x) 'GetTrail) trail)
          ((equal? (tagOf x) 'Init)
           (set! tree (make-list (cadr x) '())))
          ((equal? (tagOf x) 'FullTree)
           (rebuild tree trail))
          ((equal? (tagOf x) 'New)
           (set! tree (extend tree)))
          ((equal? (tagOf x) 'CurrentLength)
           (length tree))
          ((equal? (tagOf x) 'Delete)
           (set! tree (delete (cadr x) tree)))
          (#t (error "Wrong command."))))
  dispatch)
